delta cBase {

	//package lancs.mobilemedia.core.threads;

	adds {
		package lancs.mobilemedia.core.threads;

		public class BaseThread implements Runnable {

			public BaseThread() {
				System.out.println("BaseThread:: 0 Param Constructor used: Using default values");
			}

			public void run() {
				System.out.println("Starting BaseThread::run()");
				System.out.println("Finishing Baseathread::run()");
			}
		}
	}

	//package lancs.mobilemedia.core.ui

	adds {
		package lancs.mobilemedia.core.ui;

		import javax.microedition.midlet.MIDlet;
		import javax.microedition.midlet.MIDletStateChangeException;

		import lancs.mobilemedia.core.ui.controller.AlbumController;
		import lancs.mobilemedia.core.ui.controller.BaseController;
		import lancs.mobilemedia.core.ui.controller.PhotoListController;
		import lancs.mobilemedia.core.ui.screens.AlbumListScreen;
		import lancs.mobilemedia.core.ui.datamodel.AlbumData;

		public class MainUIMidlet extends MIDlet {

			private BaseController rootController;

			private AlbumData model;

			public MainUIMidlet() {
			}

			public void startApp() throws MIDletStateChangeException {
				model = new AlbumData();
				AlbumListScreen album = new AlbumListScreen();
				rootController = new BaseController(this, model, album);

				PhotoListController photoListController = new PhotoListController(this,
					model, album);
				photoListController.setNextController(rootController);

				AlbumController albumController = new AlbumController(this, model, album);
				albumController.setNextController(photoListController);
				album.setCommandListener(albumController);

				createAditionalControllers(model, album, albumController);

				rootController.init(model);
			}

			public void pauseApp() {
			}

			public void destroyApp(boolean unconditional) {
				notifyDestroyed();
			}

			public void createAditionalControllers(AlbumData model, AlbumListScreen album, AlbumController albumController) {
				//
			}
		}
	}

	//package lancs.mobilemedia.core.ui.controller

	adds {
		package lancs.mobilemedia.core.ui.controller;

		import java.util.HashMap;
		import java.util.Map;
		import javax.microedition.lcdui.Alert;
		import javax.microedition.lcdui.Command;
		import javax.microedition.lcdui.CommandListener;
		import javax.microedition.lcdui.Display;
		import javax.microedition.lcdui.Displayable;

		import lancs.mobilemedia.core.ui.MainUIMidlet;
		import lancs.mobilemedia.core.ui.datamodel.AlbumData;
		import lancs.mobilemedia.core.ui.screens.AlbumListScreen;

		public abstract class AbstractController implements CommandListener,
		ControllerInterface {

			private MainUIMidlet midlet;

			private AlbumData albumData;

			private ControllerInterface nextController;

			private AlbumListScreen albumListScreen;

			protected Map commands;

			protected ControllerCommandInterface command;

			public AbstractController(MainUIMidlet midlet, AlbumData albumData,
				AlbumListScreen albumListScreen) {
				this.midlet = midlet;
				this.albumData = albumData;
				this.albumListScreen = albumListScreen;
				commands = new HashMap();
				initCommandsMap();
			}

			public abstract void initCommandsMap();

			public boolean handleCommand(Command c) {

				String label = c.getLabel();
				System.out.println(this.getClass().getName() + "::handleCommand: " + label);

				command = ( ControllerCommandInterface ) commands.get(label);

				if(command != null) {
					return command.execute(this);
				}
				return false;
			}

			public void postCommand(Command c) {
				System.out.println("AbstractController::postCommand - Current controller is: " + this.getClass().getName());

				if(handleCommand(c) == false) {
					ControllerInterface next = getNextController();
					if(next != null) {
						System.out.println("Passing to next controller in chain: " + next.getClass().getName());
						next.postCommand(c);
					}
					else {
						System.out.println("AbstractController::postCommand - Reached top of chain. No more handlers for command: " + command);
					}
				}
			}

			public void commandAction(Command c, Displayable d) {
				postCommand(c);
			}

			public void setAlbumListAsCurrentScreen(Alert a) {
				setCurrentScreen(a, albumListScreen);
			}

			public void setCurrentScreen(Alert a, Displayable d) {
				Display.getDisplay(midlet).setCurrent(a, d);
			}

			public Displayable getCurrentScreen() {
				return Display.getDisplay(midlet).getCurrent();
			}

			public void setCurrentScreen(Displayable d) {
				Display.getDisplay(midlet).setCurrent(d);
			}

			public AlbumData getAlbumData() {
				return albumData;
			}

			public void setAlbumData(AlbumData albumData) {
				this.albumData = albumData;
			}

			public ControllerInterface getNextController() {
				return nextController;
			}

			public void setNextController(ControllerInterface nextController) {
				this.nextController = nextController;
			}

			public String getCurrentStoreName() {
				return ScreenSingleton.getInstance().getCurrentStoreName();
			}

			public AlbumListScreen getAlbumListScreen() {
				return albumListScreen;
			}

			public MainUIMidlet getMidlet() { //scope view changed (protected)
				return midlet;
			}
		}
	}

	adds {
		package lancs.mobilemedia.core.ui.controller;

		import lancs.mobilemedia.core.util.Constants;
		import lancs.mobilemedia.core.ui.screens.AddPhotoToAlbum;

		public class AddPhoto implements ControllerCommandInterface {

			public boolean execute(AbstractController controller) {
				ScreenSingleton.getInstance().setCurrentScreenName(Constants.ADDPHOTOTOALBUM_SCREEN);
				AddPhotoToAlbum form = new AddPhotoToAlbum("Add new Photo to Album");
				form.setCommandListener(controller);
				controller.setCurrentScreen(form);
				return true;
			}
		}
	}

	adds {
		package lancs.mobilemedia.core.ui.controller;

		import java.util.HashMap;
		import javax.microedition.lcdui.Alert;
		import javax.microedition.lcdui.AlertType;
		import javax.microedition.lcdui.Display;
		import javax.microedition.rms.RecordStoreFullException;

		import lancs.mobilemedia.core.ui.MainUIMidlet;
		import lancs.mobilemedia.core.ui.datamodel.AlbumData;
		import lancs.mobilemedia.core.ui.screens.AlbumListScreen;
		import lancs.mobilemedia.core.util.Constants;
		import lancs.mobilemedia.lib.exceptions.PersistenceMechanismException;

		public class AlbumController extends AbstractController {

			public AlbumController(MainUIMidlet midlet, AlbumData albumData,
				AlbumListScreen albumListScreen) {
				super(midlet, albumData, albumListScreen);
			}

			public void initCommandsMap() {
				commands = new HashMap();
				commands.put("Reset", new ResetAlbum());
				commands.put("Select", new SelectAlbum());
			}

			protected void resetImageData() {
				try {
					getAlbumData().resetImageData();
				}
				catch(PersistenceMechanismException e) {
					Alert alert = null;
					if(e.getCause() instanceof RecordStoreFullException) alert = new
					Alert("Error", "The mobile database is full", null, AlertType.ERROR);
					else alert = new Alert("Error",
						"It is not possible to reset the database", null, AlertType.ERROR);
					Display.getDisplay(getMidlet()).setCurrent(alert,
						Display.getDisplay(getMidlet()).getCurrent());
					return;
				}

				for(int i = 0; i < getAlbumListScreen().size(); i ++) {
					getAlbumListScreen().delete(i);
				}

				String [] albumNames = getAlbumData().getAlbumNames();
				for(int i = 0; i < albumNames.length; i ++) {
					if(albumNames[i] != null) {
						getAlbumListScreen().append(albumNames[i], null);
					}
				}
				setCurrentScreen(getAlbumListScreen());
			}

			protected void goToPreviousScreen() {
				System.out.println("<* AlbumController.goToPreviousScreen() *>");
				getAlbumListScreen().repaintListAlbum(getAlbumData().getAlbumNames());
				setCurrentScreen(getAlbumListScreen());
				ScreenSingleton.getInstance().setCurrentScreenName(Constants.ALBUMLIST_SCREEN);
			}
		}
	}

	adds {
		package lancs.mobilemedia.core.ui.controller;

		import java.util.HashMap;
		import javax.microedition.lcdui.Command;

		import lancs.mobilemedia.core.ui.MainUIMidlet;
		import lancs.mobilemedia.core.ui.datamodel.AlbumData;
		import lancs.mobilemedia.core.ui.screens.AlbumListScreen;
		import lancs.mobilemedia.core.util.Constants;

		public class BaseController extends AbstractController {

			public BaseController(MainUIMidlet midlet, AlbumData model, AlbumListScreen
				albumListScreen) {
				super(midlet, model, albumListScreen);
			}

			public void initCommandsMap() {
				commands = new HashMap();
				commands.put("Exit", new DestroyApp());
				commands.put("Back", new GoToPreviousScreen());
				commands.put("Cancel", new GoToPreviousScreen());
				commands.put("New Photo Album", new NewAlbum());
				commands.put("Save", new SaveAlbum());
				commands.put("Delete Album", new DeleteAlbum());
				commands.put("Yes - Delete", new ConfirmDeleteAlbum());
				commands.put("No - Delete", new GoToPreviousScreen());
			}

			public void init(AlbumData model) {
				String [] albumNames = model.getAlbumNames();
				for(int i = 0; i < albumNames.length; i ++) {
					if(albumNames[i] != null) {
						getAlbumListScreen().append(albumNames[i], null);
					}
				}
				getAlbumListScreen().initMenu();
				setCurrentScreen(getAlbumListScreen());
			}

			public boolean handleCommand(Command c) {

				String label = c.getLabel();
				System.out.println(this.getClass().getName() + "::handleCommand: " + label);

				command = ( ControllerCommandInterface ) commands.get(label);

				if(command != null) {
					return command.execute(this);
				}
				return false;
			}

			protected boolean goToPreviousScreen() {
				System.out.println("<* AlbumController.goToPreviousScreen() *>");
				String currentScreenName =
				ScreenSingleton.getInstance().getCurrentScreenName();
				if((currentScreenName.equals(Constants.IMAGELIST_SCREEN))
					||(currentScreenName.equals(Constants.NEWALBUM_SCREEN))
					||(currentScreenName.equals(Constants.CONFIRMDELETEALBUM_SCREEN))) {
					getAlbumListScreen().repaintListAlbum(getAlbumData().getAlbumNames());
					setCurrentScreen(getAlbumListScreen());
					ScreenSingleton.getInstance().setCurrentScreenName(Constants.ALBUMLIST_SCREEN);
					return true;
				}

				return false;
			}
		}
	}

	adds {
		package lancs.mobilemedia.core.ui.controller;

		public interface ControllerCommandInterface {

			public boolean execute(AbstractController controller);
		}
	}

	adds {
		package lancs.mobilemedia.core.ui.controller;

		import javax.microedition.lcdui.Alert;
		import javax.microedition.lcdui.AlertType;
		import javax.microedition.lcdui.Display;

		import lancs.mobilemedia.lib.exceptions.PersistenceMechanismException;

		public class ConfirmDeleteAlbum implements ControllerCommandInterface {

			public boolean execute(AbstractController controller) {
				try {
					controller.getAlbumData().deletePhotoAlbum(ScreenSingleton.getInstance().getCurrentStoreName());
				}
				catch(PersistenceMechanismException e) {
					Alert alert = new Alert("Error",
						"The mobile database can not delete this photo album", null,
						AlertType.ERROR);
					Display.getDisplay(controller.getMidlet()).setCurrent(alert,
						Display.getDisplay(controller.getMidlet()).getCurrent());
				}(( AlbumController ) controller).goToPreviousScreen();
				return true;
			}
		}
	}

	adds {
		package lancs.mobilemedia.core.ui.controller;

		import javax.microedition.lcdui.Command;

		public interface ControllerInterface {

			public void postCommand(Command c);

			public boolean handleCommand(Command c);
		}
	}

	adds {
		package lancs.mobilemedia.core.ui.controller;

		import javax.microedition.lcdui.Alert;
		import javax.microedition.lcdui.AlertType;
		import javax.microedition.lcdui.Command;
		import javax.microedition.lcdui.Display;
		import javax.microedition.lcdui.List;

		import lancs.mobilemedia.core.util.Constants;

		public class DeleteAlbum implements ControllerCommandInterface {

			public boolean execute(AbstractController controller) {
				System.out.println("Delete Photo Album here");
				List down = ( List )
				Display.getDisplay(controller.getMidlet()).getCurrent();
				ScreenSingleton.getInstance().setCurrentScreenName(Constants.CONFIRMDELETEALBUM_SCREEN);
				ScreenSingleton.getInstance().setCurrentStoreName(down.getString(down.getSelectedIndex()));
				String message = "Would you like to remove the album " +
				ScreenSingleton.getInstance().getCurrentStoreName();
				Alert deleteConfAlert = new Alert("Delete Photo Album", message, null,
					AlertType.CONFIRMATION);
				deleteConfAlert.setTimeout(Alert.FOREVER);
				deleteConfAlert.addCommand(new Command("Yes - Delete", Command.OK, 2));
				deleteConfAlert.addCommand(new Command("No - Delete", Command.CANCEL, 2));
				controller.setAlbumListAsCurrentScreen(deleteConfAlert);
				deleteConfAlert.setCommandListener(controller);
				return true;
			}
		}
	}

	adds {
		package lancs.mobilemedia.core.ui.controller;

		import javax.microedition.lcdui.Alert;
		import javax.microedition.lcdui.AlertType;
		import javax.microedition.lcdui.Display;

		import lancs.mobilemedia.core.util.Constants;
		import lancs.mobilemedia.lib.exceptions.ImageNotFoundException;
		import lancs.mobilemedia.lib.exceptions.PersistenceMechanismException;

		public class DeletePhoto implements ControllerCommandInterface {

			public boolean execute(AbstractController controller) {
				String selectedImageName =(( PhotoController )
					controller).getSelectedImageName();
				try {
					controller.getAlbumData().deleteImage(controller.getCurrentStoreName(),
						selectedImageName);
				}
				catch(PersistenceMechanismException e) {
					Alert alert = new Alert("Error",
						"The mobile database can not delete this photo", null, AlertType.ERROR);
					Display.getDisplay(controller.getMidlet()).setCurrent(alert,
						Display.getDisplay(controller.getMidlet()).getCurrent());
					return true;
				}
				catch(ImageNotFoundException e) {
					Alert alert = new Alert("Error",
						"The selected photo was not found in the mobile device", null,
						AlertType.ERROR);
					Display.getDisplay(controller.getMidlet()).setCurrent(alert,
						Display.getDisplay(controller.getMidlet()).getCurrent());
					return true;
				}(( PhotoListController )
					controller).showImageList(controller.getCurrentStoreName());
				ScreenSingleton.getInstance().setCurrentScreenName(Constants.IMAGELIST_SCREEN);
				return true;
			}
		}
	}

	adds {
		package lancs.mobilemedia.core.ui.controller;

		import lancs.mobilemedia.core.ui.controller.ControllerCommandInterface;

		public class DestroyApp implements ControllerCommandInterface {

			public boolean execute(AbstractController controller) {
				controller.getMidlet().destroyApp(true);
				return true;
			}
		}
	}

	adds {
		package lancs.mobilemedia.core.ui.controller;

		import javax.microedition.lcdui.Alert;
		import javax.microedition.lcdui.AlertType;
		import javax.microedition.lcdui.Display;

		import lancs.mobilemedia.core.ui.datamodel.AlbumData;
		import lancs.mobilemedia.core.ui.screens.NewLabelScreen;
		import lancs.mobilemedia.lib.exceptions.ImageNotFoundException;
		import lancs.mobilemedia.lib.exceptions.NullAlbumDataReference;

		public class EditPhotoLabel implements ControllerCommandInterface {

			public boolean execute(AbstractController controller) {
				String selectedImageName = ((PhotoController) controller).getSelectedImageName();
				try {
					((PhotoController) controller).setImage(controller.getAlbumData().getImageInfo(selectedImageName));

					NewLabelScreen formScreen = new NewLabelScreen("Edit Label Photo", NewLabelScreen.LABEL_PHOTO);
					formScreen.setCommandListener(controller);
					((PhotoController) controller).setScreen(formScreen);
					((PhotoController) controller).setCurrentScreen(formScreen);
					formScreen = null;
				} catch (ImageNotFoundException e) {
					Alert alert = new Alert("Error", "The selected photo was not found in the mobile device", null, AlertType.ERROR);
					Display.getDisplay(controller.getMidlet()).setCurrent(alert,
							Display.getDisplay(controller.getMidlet()).getCurrent());
				} catch (NullAlbumDataReference e) {
					controller.setAlbumData( new AlbumData() );
					Alert alert = new Alert("Error", "The operation is not available. Try again later !", null, AlertType.ERROR);
					Display.getDisplay(controller.getMidlet()).setCurrent(alert,Display.getDisplay(controller.getMidlet()).getCurrent());
				}
				return true;
			}
		}
	}

	adds {
		package lancs.mobilemedia.core.ui.controller;

		public class GoToPreviousScreen implements ControllerCommandInterface {

			public boolean execute(AbstractController controller) {(( BaseController )
					controller).goToPreviousScreen();
				return true;
			}
		}
	}

	adds {
		package lancs.mobilemedia.core.ui.controller;

		import lancs.mobilemedia.core.ui.screens.NewLabelScreen;
		import lancs.mobilemedia.core.util.Constants;

		public class NewAlbum implements ControllerCommandInterface {

			public boolean execute(AbstractController controller) {

				System.out.println("Create new Photo Album here");
				System.out.println("Create new Photo Album here");
				ScreenSingleton.getInstance().setCurrentScreenName(Constants.NEWALBUM_SCREEN);
				NewLabelScreen canv = new NewLabelScreen("Add new Photo Album", NewLabelScreen.NEW_ALBUM);
				canv.setCommandListener(controller);
				controller.setCurrentScreen(canv);
				canv = null;
				return true;
			}
		}
	}

	adds {
		package lancs.mobilemedia.core.ui.controller;

		import lancs.mobilemedia.core.util.Constants;

		public class ResetAlbum implements ControllerCommandInterface {

			public boolean execute(AbstractController controller) {
				System.out.println("<* BaseController.handleCommand() *> Reset Photo Album");
				(( AlbumController ) controller).resetImageData();
				ScreenSingleton.getInstance().setCurrentScreenName(Constants.ALBUMLIST_SCREEN);
				return true;
			}
		}
	}

	adds {
		package lancs.mobilemedia.core.ui.controller;

		import javax.microedition.lcdui.Command;
		import javax.microedition.lcdui.Alert;
		import javax.microedition.lcdui.AlertType;
		import javax.microedition.lcdui.Display;
		import javax.microedition.lcdui.Image;
		import javax.microedition.lcdui.List;
		import java.util.HashMap;

		import lancs.mobilemedia.core.ui.MainUIMidlet;
		import lancs.mobilemedia.core.ui.datamodel.AlbumData;
		import lancs.mobilemedia.core.ui.datamodel.ImageData;
		import lancs.mobilemedia.core.ui.screens.AlbumListScreen;
		import lancs.mobilemedia.core.ui.screens.NewLabelScreen;
		import lancs.mobilemedia.core.ui.screens.PhotoViewScreen;
		import lancs.mobilemedia.core.util.Constants;
		import lancs.mobilemedia.lib.exceptions.ImageNotFoundException;
		import lancs.mobilemedia.lib.exceptions.InvalidImageDataException;
		import lancs.mobilemedia.lib.exceptions.PersistenceMechanismException;

		public class PhotoController extends PhotoListController {

			private ImageData image;
			private NewLabelScreen screen;

			public PhotoController(MainUIMidlet midlet, AlbumData albumData, AlbumListScreen albumListScreen) {
				super(midlet, albumData, albumListScreen);
			}

			protected void extendedOperations(String name, PhotoViewScreen canvas, AbstractController nextController) {
				//extended by optional features - TODO create command list - must be called later
				setCurrentScreen(canvas);
			}

			public void initCommandsMap() {
				commands = new HashMap();
				commands.put("Add", new AddPhoto());
				commands.put("Save Photo", new SavePhoto());
				commands.put("Delete", new DeletePhoto());
				commands.put("Edit Label", new EditPhotoLabel());
				commands.put("Save", new SavePhotoLabel());
				commands.put("View", new ViewPhoto());
			}

			public boolean handleCommand(Command c) {

				String label = c.getLabel();
				System.out.println("<* PhotoController.handleCommand() *> " + label);

				command = (ControllerCommandInterface) commands.get(label);

				if (command != null) {
					return command.execute(this);
				}
				else if (label.equals("Back")) {
					return goToPreviousScreen();
				}
				else if (label.equals("Cancel")) {
					return goToPreviousScreen();
				}

				return false;
			}

			void updateImage(ImageData image) throws InvalidImageDataException, PersistenceMechanismException {
				getAlbumData().updateImageInfo(image, image);
			}

			public String getSelectedImageName() {
				List selected = ( List ) Display.getDisplay(getMidlet()).getCurrent();
				if(selected == null)
					System.out.println("Current List from display is NULL!");

				String name = selected.getString(selected.getSelectedIndex());
				return name;
			}

			public void showImage(String name) {
				Image storedImage = null;
				try {
					storedImage = getAlbumData().getImageFromRecordStore(getCurrentStoreName(), name);
				}
				catch(ImageNotFoundException e) {
					Alert alert = new Alert("Error", "The selected photo was not found in the mobile device",
							null, AlertType.ERROR);
					Display.getDisplay(getMidlet()).setCurrent(alert, Display.getDisplay(getMidlet()).getCurrent());
					return;
				}
				catch(PersistenceMechanismException e) {
					Alert alert = new Alert("Error", "The mobile database can open this photo", null, AlertType.ERROR);
					Display.getDisplay(getMidlet()).setCurrent(alert, Display.getDisplay(getMidlet()).getCurrent());
					return;
				}

				PhotoViewScreen canv = new PhotoViewScreen(storedImage);
				canv.setCommandListener(this);

				extendedOperations(name, canv, this);
			}

			protected boolean goToPreviousScreen() {
			//System.out.println("<* PhotoController.goToPreviousScreen() *>");
				String currentScreenName = ScreenSingleton.getInstance().getCurrentScreenName();
				if (currentScreenName.equals(Constants.ALBUMLIST_SCREEN)) {
					System.out.println("Can't go back here...Should never reach this spot");
				}
				else if(currentScreenName.equals(Constants.IMAGE_SCREEN)) {
					showImageList(getCurrentStoreName());
					ScreenSingleton.getInstance().setCurrentScreenName(Constants.IMAGELIST_SCREEN);
					return true;
				}
				else if(currentScreenName.equals(Constants.ADDPHOTOTOALBUM_SCREEN)) {
					showImageList(getCurrentStoreName());
					ScreenSingleton.getInstance().setCurrentScreenName(Constants.IMAGELIST_SCREEN);
					return true;
				}
				return false;
			}

			public void setImage(ImageData image) {
				this.image = image;
			}

			public ImageData getImage() {
				return image;
			}

			public void setScreen(NewLabelScreen screen) {
				this.screen = screen;
			}

			public NewLabelScreen getScreen() {
				return screen;
			}
		}
	}

	adds {
		package lancs.mobilemedia.core.ui.controller;

		import java.util.HashMap;
		import javax.microedition.lcdui.Alert;
		import javax.microedition.lcdui.AlertType;
		import javax.microedition.lcdui.Display;

		import lancs.mobilemedia.core.ui.MainUIMidlet;
		import lancs.mobilemedia.core.ui.datamodel.AlbumData;
		import lancs.mobilemedia.core.ui.datamodel.ImageData;
		import lancs.mobilemedia.core.ui.screens.AlbumListScreen;
		import lancs.mobilemedia.core.ui.screens.PhotoListScreen;
		import lancs.mobilemedia.lib.exceptions.UnavailablePhotoAlbumException;

		public class PhotoListController extends AbstractController {

			public static final int SHOW_IMAGE_LIST_DEFAULT_MODE = 1; //used as showImageList parameter

			public PhotoListController(MainUIMidlet midlet, AlbumData albumData,
				AlbumListScreen albumListScreen) {
				super(midlet, albumData, albumListScreen);
			}

			public void initCommandsMap() {
				commands = new HashMap();
				commands.put("Select", new SelectAlbum());
				commands.put("Add", new AddPhoto());
				commands.put("Save Photo", new SavePhoto());
			}

			public void showImageList(String recordName) {
				showImageList(recordName, SHOW_IMAGE_LIST_DEFAULT_MODE);
			}

			public void showImageList(String recordName, int imageListMode) {

				if(recordName == null) recordName = getCurrentStoreName();

				PhotoController photoController = new PhotoController(getMidlet(),
					getAlbumData(), getAlbumListScreen());
				photoController.setNextController(this);

				PhotoListScreen imageList = new PhotoListScreen();
				imageList.setCommandListener(photoController);

				imageList.initMenu();

				ImageData [] images = null;
				try {
					images = getAlbumData().getImages(recordName);
				}
				catch(UnavailablePhotoAlbumException e) {
					Alert alert = new Alert("Error", "The list of photos can not be recovered", null, AlertType.ERROR);
					Display.getDisplay(getMidlet()).setCurrent(alert, Display.getDisplay(getMidlet()).getCurrent());
					return;
				}

				if(images == null) return;

				fillImageList(imageList, images, imageListMode);

				setCurrentScreen(imageList);
			}

			private void fillImageList(PhotoListScreen imageList, ImageData [] images, int imageListMode) {

				if(imageListMode == SHOW_IMAGE_LIST_DEFAULT_MODE) {
					for(int i = 0; i < images.length; i ++) {
						if(images[i] != null) {
							imageList.append(images[i].getImageLabel(), null);
						}
					}
				}
			}
		}
	}

	adds {
		package lancs.mobilemedia.core.ui.controller;

		import java.util.HashMap;
		import javax.microedition.lcdui.Command;

		import lancs.mobilemedia.core.ui.MainUIMidlet;
		import lancs.mobilemedia.core.ui.datamodel.AlbumData;
		import lancs.mobilemedia.core.ui.screens.AlbumListScreen;

		public class PhotoViewController extends AbstractController {

			String imageName = "";

			public PhotoViewController(MainUIMidlet midlet, AlbumData albumData,
				AlbumListScreen albumListScreen, String imageName) {
				super(midlet, albumData, albumListScreen);
				this.imageName = imageName;
			}

			public void initCommandsMap() {
				commands = new HashMap();
			}

			public String getImageName() {
				return imageName;
			}

			public boolean handleCommand(Command c) {

				String label = c.getLabel();
				System.out.println("<* PhotoViewController.handleCommand() *> " + label);

				command = ( ControllerCommandInterface ) commands.get(label);

				if(command != null) {
					return command.execute(this);
				}
				return false;
			}
		}
	}

	adds {
		package lancs.mobilemedia.core.ui.controller;

		import javax.microedition.lcdui.Alert;
		import javax.microedition.lcdui.AlertType;
		import javax.microedition.lcdui.Display;
		import javax.microedition.rms.RecordStoreFullException;

		import lancs.mobilemedia.core.ui.screens.NewLabelScreen;
		import lancs.mobilemedia.lib.exceptions.InvalidPhotoAlbumNameException;
		import lancs.mobilemedia.lib.exceptions.PersistenceMechanismException;

		public class SaveAlbum implements ControllerCommandInterface {

			public boolean execute(AbstractController controller) {
				try {
					if(controller.getCurrentScreen() instanceof NewLabelScreen) {
						NewLabelScreen currentScreen = ( NewLabelScreen )
						controller.getCurrentScreen();
						if(currentScreen.getFormType() == NewLabelScreen.NEW_ALBUM)
						controller.getAlbumData().createNewPhotoAlbum(currentScreen.getLabelName());
						else if(currentScreen.getFormType() == NewLabelScreen.LABEL_PHOTO) {

						}
					}
				}
				catch(PersistenceMechanismException e) {
					Alert alert = null;
					if(e.getCause() instanceof RecordStoreFullException) alert = new
					Alert("Error", "The mobile database is full", null, AlertType.ERROR);
					else alert = new Alert("Error",
						"The mobile database can not add a new photo album", null,
						AlertType.ERROR);
					Display.getDisplay(controller.getMidlet()).setCurrent(alert,
						Display.getDisplay(controller.getMidlet()).getCurrent());
					return true;
				}
				catch(InvalidPhotoAlbumNameException e) {
					Alert alert = new Alert("Error",
						"You have provided an invalid Photo Album name", null, AlertType.ERROR);
					Display.getDisplay(controller.getMidlet()).setCurrent(alert,
						Display.getDisplay(controller.getMidlet()).getCurrent());
					return true;
				}

				GoToPreviousScreen previousScreen = new GoToPreviousScreen();
				return previousScreen.execute(controller);
			}
		}
	}

	adds {
		package lancs.mobilemedia.core.ui.controller;

		import javax.microedition.lcdui.Alert;
		import javax.microedition.lcdui.AlertType;
		import javax.microedition.lcdui.Display;
		import javax.microedition.rms.RecordStoreFullException;

		import lancs.mobilemedia.core.ui.screens.AddPhotoToAlbum;
		import lancs.mobilemedia.lib.exceptions.InvalidImageDataException;
		import lancs.mobilemedia.lib.exceptions.ImagePathNotValidException;
		import lancs.mobilemedia.lib.exceptions.PersistenceMechanismException;

		public class SavePhoto implements ControllerCommandInterface {

			public boolean execute(AbstractController controller) {
				try {
					controller.getAlbumData().addNewPhotoToAlbum(((AddPhotoToAlbum) controller.getCurrentScreen()).getPhotoName(),
							((AddPhotoToAlbum) controller.getCurrentScreen()).getPath(), controller.getCurrentStoreName());
				} catch (InvalidImageDataException e) {
					Alert alert = null;
					if (e instanceof ImagePathNotValidException)
						alert = new Alert("Error", "The path is not valid", null, AlertType.ERROR);
					else
						alert = new Alert("Error", "The image file format is not valid", null, AlertType.ERROR);
					Display.getDisplay(controller.getMidlet()).setCurrent(alert, Display.getDisplay(controller.getMidlet()).getCurrent());
					return true;
				} catch (PersistenceMechanismException e) {
					Alert alert = null;
					if (e.getCause() instanceof RecordStoreFullException)
						alert = new Alert("Error", "The mobile database is full", null, AlertType.ERROR);
					else
						alert = new Alert("Error", "The mobile database can not add a new photo", null, AlertType.ERROR);
					Display.getDisplay(controller.getMidlet()).setCurrent(alert, Display.getDisplay(controller.getMidlet()).getCurrent());
				}
				return ((PhotoController) controller).goToPreviousScreen();
			}
		}
	}

	adds {
		package lancs.mobilemedia.core.ui.controller;

		import javax.microedition.lcdui.Alert;
		import javax.microedition.lcdui.AlertType;
		import javax.microedition.lcdui.Display;

		import lancs.mobilemedia.lib.exceptions.InvalidImageDataException;
		import lancs.mobilemedia.lib.exceptions.ImagePathNotValidException;
		import lancs.mobilemedia.lib.exceptions.PersistenceMechanismException;

		public class SavePhotoLabel implements ControllerCommandInterface {

	        public boolean execute(AbstractController controller) {
                ((PhotoController) controller).getImage().setImageLabel(((PhotoController) controller).getScreen().getLabelName());
                System.out.println("<* PhotoController.handleCommand() *> Save Photo Label = " + ((PhotoController) controller).getScreen().getLabelName());
                try {
					((PhotoController) controller).updateImage(((PhotoController) controller).getImage());
                } catch (InvalidImageDataException e) {
					Alert alert = null;
					if (e instanceof ImagePathNotValidException)
						alert = new Alert("Error", "The path is not valid", null, AlertType.ERROR);
					else
						alert = new Alert("Error", "The image file format is not valid", null, AlertType.ERROR);
					Display.getDisplay(controller.getMidlet()).setCurrent(alert, Display.getDisplay(controller.getMidlet()).getCurrent());
                } catch (PersistenceMechanismException e) {
					Alert alert = new Alert("Error", "The mobile database can not update this photo", null, AlertType.ERROR);
					Display.getDisplay(controller.getMidlet()).setCurrent(alert, Display.getDisplay(controller.getMidlet()).getCurrent());
                }
                return ((PhotoController) controller).goToPreviousScreen();
	        }
		}
	}

	adds {
		package lancs.mobilemedia.core.ui.controller;

		public class ScreenSingleton {

			private static ScreenSingleton instance;
			private String currentScreenName;
			private String currentStoreName = "My Photo Album";

			private ScreenSingleton() {
			}

			public static ScreenSingleton getInstance() {
				if(instance == null) instance = new ScreenSingleton();
				return instance;
			}

			public void setCurrentScreenName(String currentScreenName) {
				this.currentScreenName = currentScreenName;
			}

			public String getCurrentScreenName() {
				return currentScreenName;
			}

			public void setCurrentStoreName(String currentStoreName) {
				this.currentStoreName = currentStoreName;
			}

			public String getCurrentStoreName() {
				return currentStoreName;
			}
		}
	}

	adds {
		package lancs.mobilemedia.core.ui.controller;

		import javax.microedition.lcdui.Display;
		import javax.microedition.lcdui.List;

		import lancs.mobilemedia.core.util.Constants;

		public class SelectAlbum implements ControllerCommandInterface {

			public boolean execute(AbstractController controller) {
				List down = ( List )
				Display.getDisplay(controller.getMidlet()).getCurrent();
				ScreenSingleton.getInstance().setCurrentStoreName(down.getString(down.getSelectedIndex()));((
					PhotoListController )
					controller).showImageList(controller.getCurrentStoreName());
				ScreenSingleton.getInstance().setCurrentScreenName(Constants.IMAGELIST_SCREEN);
				return true;
			}
		}
	}

	adds {
		package lancs.mobilemedia.core.ui.controller;

		import lancs.mobilemedia.core.util.Constants;

		public class ViewPhoto implements ControllerCommandInterface {

			public boolean execute(AbstractController controller) {
				((PhotoController) controller).showImage( ((PhotoController) controller).getSelectedImageName() );
				ScreenSingleton.getInstance().setCurrentScreenName(Constants.IMAGE_SCREEN);
				return true;
			}
		}
	}

	//package lancs.mobilemedia.core.ui.datamodel

	adds {
		package lancs.mobilemedia.core.ui.datamodel;

		import java.util.Hashtable;
		import javax.microedition.lcdui.Image;

		import lancs.mobilemedia.lib.exceptions.ImageNotFoundException;
		import lancs.mobilemedia.lib.exceptions.InvalidImageDataException;
		import lancs.mobilemedia.lib.exceptions.InvalidPhotoAlbumNameException;
		import lancs.mobilemedia.lib.exceptions.NullAlbumDataReference;
		import lancs.mobilemedia.lib.exceptions.PersistenceMechanismException;
		import lancs.mobilemedia.lib.exceptions.UnavailablePhotoAlbumException;

		public class AlbumData {

			protected ImageAccessor imageAccessor;

			protected Hashtable imageInfoTable = new Hashtable();

			public boolean existingRecords = false;

			public AlbumData() {
				imageAccessor = new ImageAccessor(( AlbumData ) this);
			}

			public String [] getAlbumNames() {
				try {
					imageAccessor.loadAlbums();
				}
				catch(InvalidImageDataException e) {
					e.printStackTrace();
				}
				catch(PersistenceMechanismException e) {
					e.printStackTrace();
				}
				return imageAccessor.getAlbumNames();
			}

			public ImageData [] getImages(String recordName)
					throws UnavailablePhotoAlbumException {

				ImageData [] result;
				try {
					result = imageAccessor.loadImageDataFromRMS(recordName);
				}
				catch(PersistenceMechanismException e) {
					throw new UnavailablePhotoAlbumException(e);

				}
				catch(InvalidImageDataException e) {
					throw new UnavailablePhotoAlbumException(e);
				}

				return result;
			}

			public Image getImageFromRecordStore(String recordStore, String imageName)
					throws ImageNotFoundException, PersistenceMechanismException {

				ImageData imageInfo = null;
				try {
					imageInfo = imageAccessor.getImageInfo(imageName);
				}
				catch(NullAlbumDataReference e) {
					imageAccessor = new ImageAccessor(this);
				}
				int imageId = imageInfo.getForeignRecordId();
				String album = imageInfo.getParentAlbumName();
				Image imageRec = imageAccessor.loadSingleImageFromRMS(album, imageName, imageId);
				return imageRec;

			}

			public void resetImageData() throws PersistenceMechanismException {
				try {
					imageAccessor.resetImageRecordStore();
				}
				catch(InvalidImageDataException e) {
					e.printStackTrace();
				}
			}

			public ImageData getImageInfo(String name) throws ImageNotFoundException,
			NullAlbumDataReference {
				return imageAccessor.getImageInfo(name);
			}

			public Hashtable getImageInfoTable() {
				return imageInfoTable;
			}

			public void setImageInfoTable(Hashtable imageInfoTable) {
				this.imageInfoTable = imageInfoTable;
			}

			public void createNewPhotoAlbum(String albumName)
					throws PersistenceMechanismException, InvalidPhotoAlbumNameException {
				imageAccessor.createNewPhotoAlbum(albumName);
			}

			public void deletePhotoAlbum(String albumName) throws PersistenceMechanismException {
				imageAccessor.deletePhotoAlbum(albumName);
			}

			public void addNewPhotoToAlbum(String label, String path, String album)
					throws InvalidImageDataException, PersistenceMechanismException {
				imageAccessor.addImageData(label, path, album);
			}

			public void deleteImage(String imageName, String storeName)
					throws PersistenceMechanismException, ImageNotFoundException {
				try {
					imageAccessor.deleteSingleImageFromRMS(imageName, storeName);
				}
				catch(NullAlbumDataReference e) {
					imageAccessor = new ImageAccessor(this);
					e.printStackTrace();
				}
			}

			public void updateImageInfo(ImageData oldData, ImageData newData)
					throws InvalidImageDataException, PersistenceMechanismException {
				imageAccessor.updateImageInfo(oldData, newData);
			}
		}
	}

	adds {
		package lancs.mobilemedia.core.ui.datamodel;

		import java.util.Vector;

		import javax.microedition.lcdui.Image;
		import javax.microedition.rms.RecordEnumeration;
		import javax.microedition.rms.RecordStore;
		import javax.microedition.rms.RecordStoreException;
		import javax.microedition.rms.RecordStoreNotOpenException;

		import lancs.mobilemedia.core.util.ImageUtil;
		import lancs.mobilemedia.lib.exceptions.ImageNotFoundException;
		import lancs.mobilemedia.lib.exceptions.InvalidImageDataException;
		import lancs.mobilemedia.lib.exceptions.InvalidPhotoAlbumNameException;
		import lancs.mobilemedia.lib.exceptions.NullAlbumDataReference;
		import lancs.mobilemedia.lib.exceptions.PersistenceMechanismException;

		public class ImageAccessor {

			public static final String ALBUM_LABEL = "mpa-";
			public static final String INFO_LABEL = "mpi-";

			public static final String DEFAULT_ALBUM_NAME = "My Photo Album";
			public static final String IMAGE_LABEL = "ImageList";

			protected String [] albumNames;

			protected AlbumData model;

			private RecordStore imageRS = null;
			private RecordStore imageInfoRS = null;

			public ImageAccessor(AlbumData modelParam) {
				model = modelParam;
			}

			public void loadAlbums() throws InvalidImageDataException, PersistenceMechanismException {
				String [] currentStores = RecordStore.listRecordStores();

				if(currentStores != null) {
					System.out.println("ImageAccessor::loadAlbums: Found: " +
						currentStores.length + " existing record stores");
					model.existingRecords = true;
					String [] temp = new String[currentStores.length];
					int count = 0;

					for(int i = 0; i < currentStores.length; i ++) {
						String curr = currentStores[i];

						if(curr.startsWith(ALBUM_LABEL)) {
							curr = curr.substring(4);
							temp[i] = curr;
							count ++;
						}
					}

					albumNames = new String[count];
					int count2 = 0;
					for(int i = 0; i < temp.length; i ++) {
						if(temp[i] != null) {
							albumNames[count2] = temp[i];
							count2 ++;
						}
					}
				}
				else {
					System.out.println("ImageAccessor::loadAlbums: 0 record stores exist. Creating default one.");
					resetImageRecordStore();
					loadAlbums();
				}
			}

			public void resetImageRecordStore() throws InvalidImageDataException, PersistenceMechanismException {

				String storeName = null;
				String infoStoreName = null;

				if(albumNames != null) {
					for(int i = 0; i < albumNames.length; i ++) {
						try {
							storeName = ALBUM_LABEL + albumNames[i];
							infoStoreName = INFO_LABEL + albumNames[i];

							RecordStore.deleteRecordStore(storeName);
							RecordStore.deleteRecordStore(infoStoreName);
						}
						catch(RecordStoreException e) {
							System.out.println("No record store named " + storeName + " to delete.");
							System.out.println("...or...No record store named " + infoStoreName + " to delete.");
							System.out.println("Ignoring Exception: " + e);
						}
					}
				}
				else {
					System.out.println("ImageAccessor::resetImageRecordStore: albumNames array was null. Nothing to delete.");
				}

				createDefaultAlbum();
			}

			private void createDefaultAlbum() throws InvalidImageDataException, PersistenceMechanismException {
				addImageData("Tucan Sam", "/images/Tucan.png", ImageAccessor.DEFAULT_ALBUM_NAME);
				addImageData("Linux Penguin", "/images/Penguin.png", ImageAccessor.DEFAULT_ALBUM_NAME);
				addImageData("Duke (Sun)", "/images/Duke1.PNG", ImageAccessor.DEFAULT_ALBUM_NAME);
				addImageData("UBC Logo", "/images/ubcLogo.PNG", ImageAccessor.DEFAULT_ALBUM_NAME);
				addImageData("Gail", "/images/Gail1.PNG", ImageAccessor.DEFAULT_ALBUM_NAME);
				addImageData("J. Gosling", "/images/Gosling1.PNG", ImageAccessor.DEFAULT_ALBUM_NAME);
				addImageData("Gregor", "/images/Gregor1.PNG", ImageAccessor.DEFAULT_ALBUM_NAME);
				addImageData("Kris", "/images/Kdvolder1.PNG", ImageAccessor.DEFAULT_ALBUM_NAME);
			}

			public void addImageData(String photoname, String path, String albumname)
					throws InvalidImageDataException, PersistenceMechanismException {

				try {
					imageRS = RecordStore.openRecordStore(ALBUM_LABEL + albumname, true);
					imageInfoRS = RecordStore.openRecordStore(INFO_LABEL + albumname, true);

					int rid; // new record ID for Image (bytes)
					int rid2; // new record ID for ImageData (metadata)

					ImageUtil converter = new ImageUtil();

					byte [] data1 = converter.readImageAsByteArray(path);
					rid = imageRS.addRecord(data1, 0, data1.length);
					ImageData ii = new ImageData(rid, ImageAccessor.ALBUM_LABEL + albumname, photoname);
					rid2 = imageInfoRS.getNextRecordID();
					ii.setRecordId(rid2);
					data1 = converter.getBytesFromImageInfo(ii);
					imageInfoRS.addRecord(data1, 0, data1.length);

					imageRS.closeRecordStore();

					imageInfoRS.closeRecordStore();
				}
				catch(RecordStoreException e) {
					throw new PersistenceMechanismException();
				}
			}

			public ImageData [] loadImageDataFromRMS(String recordName)
					throws PersistenceMechanismException, InvalidImageDataException {

				Vector imagesVector = new Vector();

				try {

					String infoStoreName = ImageAccessor.INFO_LABEL + recordName;

					RecordStore infoStore = RecordStore.openRecordStore(infoStoreName, false);
					RecordEnumeration isEnum = infoStore.enumerateRecords(null, null, false);

					while(isEnum.hasNextElement()) {
					// Get next record
						int currentId = isEnum.nextRecordId();
						byte [] data = infoStore.getRecord(currentId);

						ImageUtil converter = new ImageUtil();
						ImageData iiObject = converter.getImageInfoFromBytes(data);

						String label = iiObject.getImageLabel();
						imagesVector.addElement(label);
						model.getImageInfoTable().put(label, iiObject);

					}

					infoStore.closeRecordStore();
				}
				catch(RecordStoreException rse) {
					throw new PersistenceMechanismException(rse);
				}

				// Re-copy the contents into a smaller array
				ImageData [] labelArray = new ImageData[imagesVector.size()];
				imagesVector.copyInto(labelArray);
				return labelArray;
			}

			public boolean updateImageInfo(ImageData oldData, ImageData newData)
					throws InvalidImageDataException, PersistenceMechanismException {

				boolean success = false;
				RecordStore infoStore = null;
				try {
					String infoStoreName = oldData.getParentAlbumName();
					infoStoreName = ImageAccessor.INFO_LABEL +
					infoStoreName.substring(ImageAccessor.ALBUM_LABEL.length());
					infoStore = RecordStore.openRecordStore(infoStoreName, false);

					ImageUtil converter = new ImageUtil();
					byte [] imageDataBytes = converter.getBytesFromImageInfo(newData);

					infoStore.setRecord(oldData.getRecordId(), imageDataBytes, 0,
						imageDataBytes.length);

				}
				catch(RecordStoreException rse) {
					throw new PersistenceMechanismException(rse);
				}

				setImageInfo(oldData.getImageLabel(), newData);

				try {
					infoStore.closeRecordStore();
				}
				catch(RecordStoreNotOpenException e) {
				}
				catch(RecordStoreException e) {
					throw new PersistenceMechanismException(e);
				}

				return success;
			}

			public ImageData getImageInfo(String imageName)
					throws ImageNotFoundException, NullAlbumDataReference {
				if(model == null) throw new NullAlbumDataReference("Null reference to the Album data");

				ImageData ii = ( ImageData ) model.getImageInfoTable().get(imageName);

				if(ii == null) throw new ImageNotFoundException(imageName + " was NULL in ImageAccessor Hashtable.");

				return ii;
			}

			public void setImageInfo(String imageName, ImageData newData) {
				model.getImageInfoTable().put(newData.getImageLabel(), newData);
			}

			public Image loadSingleImageFromRMS(String recordName, String imageName,
					int recordId) throws PersistenceMechanismException {

				Image img = null;
				byte [] imageData = loadImageBytesFromRMS(recordName, imageName, recordId);
				img = Image.createImage(imageData, 0, imageData.length);
				return img;
			}

			public byte [] loadImageBytesFromRMS(String recordName, String imageName,
					int recordId) throws PersistenceMechanismException {

				byte [] imageData = null;

				try {
					RecordStore albumStore = RecordStore.openRecordStore(recordName, false);
					imageData = albumStore.getRecord(recordId);
					albumStore.closeRecordStore();
				}
				catch(RecordStoreException rse) {
					throw new PersistenceMechanismException(rse);
				}

				return imageData;
			}

			public boolean deleteSingleImageFromRMS(String storeName, String imageName)
					throws PersistenceMechanismException, ImageNotFoundException, NullAlbumDataReference {

				boolean success = false;

				try {
					imageRS = RecordStore.openRecordStore(ALBUM_LABEL + storeName, true);
					imageInfoRS = RecordStore.openRecordStore(INFO_LABEL + storeName, true);

					ImageData imageData = getImageInfo(imageName);
					int rid = imageData.getForeignRecordId();

					imageRS.deleteRecord(rid);
					imageInfoRS.deleteRecord(rid);

					imageRS.closeRecordStore();
					imageInfoRS.closeRecordStore();

				}
				catch(RecordStoreException rse) {
					throw new PersistenceMechanismException(rse);
				}
				return success;
			}

			public void createNewPhotoAlbum(String albumName)
					throws PersistenceMechanismException, InvalidPhotoAlbumNameException {

				RecordStore newAlbumRS = null;
				RecordStore newAlbumInfoRS = null;
				if(albumName.equals("")) {
					System.out.println("Deve ter levantado ex");
					throw new InvalidPhotoAlbumNameException();
				}
				String [] names = getAlbumNames();
				for(int i = 0; i < names.length; i ++) {
					if(names[i].equals(albumName))
						throw new InvalidPhotoAlbumNameException();
				}

				try {
					newAlbumRS = RecordStore.openRecordStore(ALBUM_LABEL + albumName, true);
					newAlbumInfoRS = RecordStore.openRecordStore(INFO_LABEL + albumName, true);
					newAlbumRS.closeRecordStore();
					newAlbumInfoRS.closeRecordStore();
				}
				catch(RecordStoreException rse) {
					throw new PersistenceMechanismException(rse);
				}
			}

			public void deletePhotoAlbum(String albumName) throws PersistenceMechanismException {
				try {
					RecordStore.deleteRecordStore(ALBUM_LABEL + albumName);
					RecordStore.deleteRecordStore(INFO_LABEL + albumName);
				}
				catch(RecordStoreException rse) {
					throw new PersistenceMechanismException(rse);
				}
			}

			public String [] getAlbumNames() {
				return albumNames;
			}
		}
	}

	adds {
		package lancs.mobilemedia.core.ui.datamodel;

		public class ImageData {

			private int recordId;
			private int foreignRecordId;
			private String parentAlbumName;
			private String imageLabel;

			public ImageData(int foreignRecordId, String parentAlbumName, String
				imageLabel) {
				super();
				this.foreignRecordId = foreignRecordId;
				this.parentAlbumName = parentAlbumName;
				this.imageLabel = imageLabel;
			}

			public int getRecordId() {
				return recordId;
			}

			public void setRecordId(int recordIdParam) {
				recordId = recordIdParam;
			}

			public int getForeignRecordId() {
				return foreignRecordId;
			}

			public void setForeignRecordId(int foreignRecordIdParam) {
				foreignRecordId = foreignRecordIdParam;
			}

			public String getImageLabel() {
				return imageLabel;
			}

			public void setImageLabel(String imageLabelParam) {
				imageLabel = imageLabelParam;
			}

			public String getParentAlbumName() {
				return parentAlbumName;
			}

			public void setParentAlbumName(String parentAlbumNameParam) {
				parentAlbumName = parentAlbumNameParam;
			}
		}
	}

	//package lancs.mobilemedia.core.ui.screens

	adds {
		package lancs.mobilemedia.core.ui.screens;

		import javax.microedition.lcdui.Command;
		import javax.microedition.lcdui.Form;
		import javax.microedition.lcdui.TextField;

		public class AddPhotoToAlbum extends Form {

			TextField labeltxt = new TextField("Photo label", "", 15, TextField.ANY);
			TextField photopathtxt = new TextField("Path", "", 20, TextField.ANY);

			Command ok;
			Command cancel;

			public AddPhotoToAlbum(String title) {
				super(title);
				this.append(labeltxt);
				this.append(photopathtxt);
				ok = new Command("Save Add Photo", Command.SCREEN, 0);
				cancel = new Command("Cancel", Command.EXIT, 1);
				this.addCommand(ok);
				this.addCommand(cancel);
			}

			public String getPhotoName() {
				return labeltxt.getString();
			}

			public void setPhotoName(String photoName) {
				labeltxt.setString(photoName);
			}

			public String getPath() {
				return photopathtxt.getString();
			}

			public void setLabePhotoPath(String label) {
				photopathtxt.setLabel(label);
			}
		}
	}

	adds {
		package lancs.mobilemedia.core.ui.screens;

		import javax.microedition.lcdui.Choice;
		import javax.microedition.lcdui.Command;
		import javax.microedition.lcdui.Image;
		import javax.microedition.lcdui.List;

		public class AlbumListScreen extends List {

			public static final Command exitCommand = new Command("Exit", Command.STOP,
				2);
			public static final Command selectCommand = new Command("Select",
				Command.ITEM, 1);
			public static final Command resetCommand = new Command("Reset",
				Command.ITEM, 1);
			public static final Command createAlbumCommand = new
			Command("New Photo Album", Command.ITEM, 1);
			public static final Command deleteAlbumCommand = new
			Command("Delete Album", Command.ITEM, 1);

			public AlbumListScreen() {
				super("Select Album", Choice.IMPLICIT);
			}

			public AlbumListScreen(String arg0, int arg1) {
				super(arg0, arg1);
			}

			public AlbumListScreen(String arg0, int arg1, String [] arg2, Image []
				arg3) {
				super(arg0, arg1, arg2, arg3);
			}

			public void initMenu() {
				this.addCommand(exitCommand);
				this.addCommand(selectCommand);
				this.addCommand(resetCommand);
				this.addCommand(createAlbumCommand);
				this.addCommand(deleteAlbumCommand);
			}

			public void deleteAll() {
				for(int i = 0; i < this.size(); i ++) {
					this.delete(i);
				}
			}

			public void repaintListAlbum(String [] names) {
				String [] albumNames = names;
				this.deleteAll();
				for(int i = 0; i < albumNames.length; i ++) {
					if(albumNames[i] != null) {
						this.append(albumNames[i], null);
					}
				}
			}
		}
	}

	adds {
		package lancs.mobilemedia.core.ui.screens;

		import javax.microedition.lcdui.Command;
		import javax.microedition.lcdui.Form;
		import javax.microedition.lcdui.Item;
		import javax.microedition.lcdui.TextField;

		public class NewLabelScreen extends Form {

			public static final int NEW_ALBUM = 0;
			public static final int LABEL_PHOTO = 1;

			TextField labelName = new TextField("Name", "", 15, TextField.ANY);

			Command ok;
			Command cancel;

			private int formType;

			public NewLabelScreen(String name, int type) {
				super(name);
				this.formType = type;
				this.append(labelName);
				ok = new Command("Save", Command.SCREEN, 0);
				cancel = new Command("Cancel", Command.EXIT, 1);
				this.addCommand(ok);
				this.addCommand(cancel);
			}

			public NewLabelScreen(String title, Item [] items) {
				super(title, items);
			}

			public String getLabelName() {
				return labelName.getString();
			}

			public void setFormType(int formType) {
				this.formType = formType;
			}

			public int getFormType() {
				return formType;
			}
		}
	}

	adds {
		package lancs.mobilemedia.core.ui.screens;

		import javax.microedition.lcdui.Choice;
		import javax.microedition.lcdui.Command;
		import javax.microedition.lcdui.List;

		public class PhotoListScreen extends List {

			public static final Command backCommand = new Command("Back", Command.BACK, 0);
			public static final Command addCommand = new Command("Add", Command.ITEM, 1);
			public static final Command deleteCommand = new Command("Delete", Command.ITEM, 1);
			public static final Command editLabelCommand = new Command("Edit Label", Command.ITEM, 1);

			public PhotoListScreen() {
				super("Choose Items", Choice.IMPLICIT);
			}

			public void initMenu() {
				this.addCommand(backCommand);
				this.addCommand(addCommand);
				this.addCommand(deleteCommand);
				this.addCommand(editLabelCommand);
			}
		}
	}

	adds {
		package lancs.mobilemedia.core.ui.screens;

		import javax.microedition.lcdui.Alert;
		import javax.microedition.lcdui.AlertType;
		import javax.microedition.lcdui.Canvas;
		import javax.microedition.lcdui.Command;
		import javax.microedition.lcdui.Graphics;
		import javax.microedition.lcdui.Image;

		import lancs.mobilemedia.core.ui.datamodel.AlbumData;
		import lancs.mobilemedia.core.util.Constants;
		import lancs.mobilemedia.lib.exceptions.ImageNotFoundException;
		import lancs.mobilemedia.lib.exceptions.PersistenceMechanismException;

		public class PhotoViewScreen extends Canvas {

			String imageName = "";
			Image image;

			AlbumData model = null;

			public static final Command backCommand = new Command("Back", Command.BACK, 0);

			public PhotoViewScreen(Image img) {
				image = img;
				initMenu();
			}

			public PhotoViewScreen(AlbumData mod, String name) {
				imageName = name;
				model = mod;
				try {
					loadImage();
				}
				catch(ImageNotFoundException e) {
					Alert alert = new Alert("Error", "The selected image can not be found",
							null, AlertType.ERROR);
					alert.setTimeout(5000);
				}
				catch(PersistenceMechanismException e) {
					Alert alert = new Alert("Error", "It was not possible to recovery the selected image",
							null, AlertType.ERROR);
					alert.setTimeout(5000);
				}
				initMenu();
			}

			protected void initMenu() {
				this.addCommand(backCommand);
			}

			public void loadImage() throws ImageNotFoundException, PersistenceMechanismException {
				image = model.getImageFromRecordStore(null, imageName);
			}

			protected void paint(Graphics g) {
				g.setGrayScale(255);
				g.fillRect(0, 0, Constants.SCREEN_WIDTH, Constants.SCREEN_HEIGHT);
				System.out.println("Screen size:" + Constants.SCREEN_WIDTH + ":" + Constants.SCREEN_HEIGHT);

				if(image == null)
				System.out.println("PhotoViewScreen::paint(): Image object was null.");

				g.drawImage(image, 0, 0, Graphics.TOP | Graphics.LEFT);

			}
		}
	}

	//package lancs.mobilemedia.core.util;

	adds {
		package lancs.mobilemedia.core.util;

		public class Constants {

			public static final int SCREEN_WIDTH = 176;
			public static final int SCREEN_HEIGHT = 205;

			public static final String ALBUMLIST_SCREEN = "AlbumListScreen";
			public static final String NEWALBUM_SCREEN = "NewAlbumScreen";
			public static final String CONFIRMDELETEALBUM_SCREEN =
			"ConfirmDeleteAlbumScreen";

			public static final String IMAGE_SCREEN = "ImageScreen";
			public static final String IMAGELIST_SCREEN = "ImageListScreen";
			public static final String ADDPHOTOTOALBUM_SCREEN = "AddPhotoToAlbum";
		}
	}

	adds {
		package lancs.mobilemedia.core.util;

		import java.io.IOException;
		import java.io.InputStream;

		import lancs.mobilemedia.core.ui.datamodel.ImageData;
		import lancs.mobilemedia.lib.exceptions.ImagePathNotValidException;
		import lancs.mobilemedia.lib.exceptions.InvalidArrayFormatException;
		import lancs.mobilemedia.lib.exceptions.InvalidImageDataException;
		import lancs.mobilemedia.lib.exceptions.InvalidImageFormatException;

		public class ImageUtil {

			private static final String DELIMITER = "*";

			public ImageUtil() {
				super();
			}

			public byte [] readImageAsByteArray(String imageFile)
					throws ImagePathNotValidException, InvalidImageFormatException {

				byte bArray [] = new byte[1000];

				InputStream is = null;
				try {
					is = ( InputStream ) this.getClass().getResourceAsStream(imageFile);
				}
				catch(Exception e) {
					throw new ImagePathNotValidException("Path not valid for this image:" + imageFile);
				}

				int i, len = 0;
				byte bArray2 [];
				byte b [] = new byte[1];
				try {
					while(is.read(b) != - 1) {
						if(len + 1 >= bArray.length) {
							bArray2 = new byte[bArray.length];

							for(i = 0; i < len; i ++) bArray2[i] = bArray[i];

							bArray = new byte[bArray2.length + 500];

							for(i = 0; i < len; i ++) bArray[i] = bArray2[i];
						}
						bArray[len] = b[0];
						len ++;
					}
					is.close();
				}
				catch(IOException e1) {
					throw new InvalidImageFormatException("The file " + imageFile + " does not have PNG format");
				}
				catch(NullPointerException e2) {
					throw new ImagePathNotValidException("Path not valid for this image:" + imageFile);
				}
				return bArray;
			}

			public ImageData getImageInfoFromBytes(byte [] bytes) throws InvalidArrayFormatException {

				try {
					String iiString = new String(bytes);

					int startIndex = 0;
					int endIndex = iiString.indexOf(DELIMITER);
					String intString = iiString.substring(startIndex, endIndex);

					startIndex = endIndex + 1;
					endIndex = iiString.indexOf(DELIMITER, startIndex);
					String fidString = iiString.substring(startIndex, endIndex);

					startIndex = endIndex + 1;
					endIndex = iiString.indexOf(DELIMITER, startIndex);
					String albumLabel = iiString.substring(startIndex, endIndex);

					startIndex = endIndex + 1;
					endIndex = iiString.indexOf(DELIMITER, startIndex);

					if(endIndex == - 1) endIndex = iiString.length();

					String imageLabel = iiString.substring(startIndex, endIndex);

					if((endIndex + 1) < iiString.length()) {
						startIndex = endIndex + 1;
						endIndex = iiString.indexOf(DELIMITER, startIndex);
						if(endIndex == - 1) endIndex = iiString.length();

						iiString.substring(startIndex, endIndex);
					}

					Integer x = Integer.valueOf(fidString);
					ImageData ii = new ImageData(x.intValue(), albumLabel, imageLabel);
					x = Integer.valueOf(intString);
					ii.setRecordId(x.intValue());
					return ii;
				}
				catch(Exception e) {
					throw new InvalidArrayFormatException();
				}
			}

			public byte [] getBytesFromImageInfo(ImageData ii) throws InvalidImageDataException {
				try {
					String byteString = retrieveImageByteString(ii);
					return byteString.getBytes();
				}
				catch(Exception e) {
					throw new InvalidImageDataException("The provided data are not valid");
				}
			}

			private String retrieveImageByteString(ImageData ii) {
				String byteString = new String();

				int i = ii.getRecordId();
				Integer j = new Integer(i);
				byteString = byteString.concat(j.toString());
				byteString = byteString.concat(DELIMITER);

				int i2 = ii.getForeignRecordId();
				Integer j2 = new Integer(i2);
				byteString = byteString.concat(j2.toString());
				byteString = byteString.concat(DELIMITER);

				byteString = byteString.concat(ii.getParentAlbumName());
				byteString = byteString.concat(DELIMITER);

				byteString = byteString.concat(ii.getImageLabel());

				return byteString;
			}
		}
	}

	//package lancs.mobilemedia.lib.exceptions

	adds {
		package lancs.mobilemedia.lib.exceptions;

		public class InvalidImageDataException extends Exception {

			private Throwable cause;

			public InvalidImageDataException() {
				super();
			}

			public InvalidImageDataException(String arg0) {
				super(arg0);
			}

			public InvalidImageDataException(Throwable arg0) {
				cause = arg0;
			}

			public Throwable getCause() {
				return cause;
			}
		}
	}

	adds {
		package lancs.mobilemedia.lib.exceptions;

		public class InvalidImageFormatException extends InvalidImageDataException {

			public InvalidImageFormatException() {
			}

			public InvalidImageFormatException(String arg0) {
				super(arg0);
			}

			public InvalidImageFormatException(Throwable arg0) {
				super(arg0);
			}
		}
	}

	adds {
		package lancs.mobilemedia.lib.exceptions;

		public class ImageNotFoundException extends Exception {

			private Throwable cause;

			public ImageNotFoundException() {
			}

			public ImageNotFoundException(String arg0) {
				super(arg0);
			}

			public ImageNotFoundException(Throwable arg0) {
				cause = arg0;
			}

			public Throwable getCause() {
				return cause;
			}
		}
	}

	adds {
		package lancs.mobilemedia.lib.exceptions;

		public class ImagePathNotValidException extends InvalidImageDataException {

			private Throwable cause;

			public ImagePathNotValidException() {
			}

			public ImagePathNotValidException(String arg0) {
				super(arg0);
			}

			public ImagePathNotValidException(Throwable arg0) {
				cause = arg0;
			}

			public Throwable getCause() {
				return cause;
			}
		}
	}

	adds {
		package lancs.mobilemedia.lib.exceptions;

		public class InvalidArrayFormatException extends InvalidImageDataException {

			public InvalidArrayFormatException() {
				super();
			}

			public InvalidArrayFormatException(String arg0) {
				super(arg0);

			}

			public InvalidArrayFormatException(Throwable arg0) {
				super(arg0);
			}
		}
	}

	adds {
		package lancs.mobilemedia.lib.exceptions;

		public class PersistenceMechanismException extends Exception {

			public PersistenceMechanismException(String arg0) {
				super(arg0);
			}

			public PersistenceMechanismException() {
			}

			private Throwable cause;

			public PersistenceMechanismException(Throwable arg0) {
				cause = arg0;
			}

			public Throwable getCause() {
				return cause;
			}
		}
	}

	adds {
		package lancs.mobilemedia.lib.exceptions;

		public class NullAlbumDataReference extends Exception {

			private Throwable cause;

			public NullAlbumDataReference() {
			}

			public NullAlbumDataReference(String arg0) {
				super(arg0);
			}

			public NullAlbumDataReference(Throwable arg0) {
				cause = arg0;
			}

			public Throwable getCause() {
				return cause;
			}
		}
	}

	adds {
		package lancs.mobilemedia.lib.exceptions;

		public class InvalidPhotoAlbumNameException extends Exception {

			public InvalidPhotoAlbumNameException() {
			}

			public InvalidPhotoAlbumNameException(String s) {
				super(s);
			}
		}
	}

	adds {
		package lancs.mobilemedia.lib.exceptions;

		public class UnavailablePhotoAlbumException extends Exception {

			private Throwable cause;

			public UnavailablePhotoAlbumException() {
			}

			public UnavailablePhotoAlbumException(String arg0) {
				super(arg0);
			}

			public UnavailablePhotoAlbumException(Throwable arg0) {
				cause = arg0;
			}

			public Throwable getCause() {
				return cause;
			}
		}
	}
}